import type {
  Redaction,
  RedactionPart,
  RedactionRule,
  BoundingBox,
  HighlightInProgress,
  PageData
} from '../types'

/**
 * Generate a UUID for redaction IDs
 */
export function generateUUID(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0
    const v = c === 'x' ? r : (r & 0x3) | 0x8
    return v.toString(16)
  })
}

/**
 * Calculate the bounding box that encompasses all parts of a redaction
 */
export function boundingBox(redaction: Redaction): BoundingBox {
  const xs0 = redaction.parts.map(part => part.x)
  const ys0 = redaction.parts.map(part => part.y)
  const xs1 = redaction.parts.map(part => part.x + part.width)
  const ys1 = redaction.parts.map(part => part.y + part.height)
  return {
    x0: Math.min(...xs0),
    y0: Math.min(...ys0),
    x1: Math.max(...xs1),
    y1: Math.max(...ys1)
  }
}

/**
 * Convert a quad array (from MuPDF search results) to a RedactionPart
 */
export function quadToPart(quad: number[]): RedactionPart {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = quad
  const x = Math.min(x0, x1, x2, x3)
  const y = Math.min(y0, y1, y2, y3)
  const w = Math.max(x0, x1, x2, x3) - x
  const h = Math.max(y0, y1, y2, y3) - y
  return { x, y, width: w, height: h }
}

/**
 * Convert MuPDF search result quads to a Redaction object
 */
export function resultToRedaction(
  result: number[][],
  pageIndex: number,
  options: {
    rule?: RedactionRule
    shouldApply?: boolean
    reason?: string
    isAutoGenerated?: boolean
    isIndeterminate?: boolean
  } = {}
): Redaction {
  const parts = result.map(quad => quadToPart(quad))
  return {
    id: generateUUID(),
    pageIndex,
    parts,
    rule: options.rule,
    shouldApply: options.shouldApply ?? true,
    reason: options.reason,
    isAutoGenerated: options.isAutoGenerated ?? false,
    isIndeterminate: options.isIndeterminate ?? false
  }
}

/**
 * Finalize a highlight-in-progress into a proper Redaction
 */
export function finalizeHighlight(
  page: PageData,
  highlight: HighlightInProgress
): Redaction {
  if (highlight.type === 'freehand') {
    const x = Math.min(highlight.startX, highlight.endX)
    const y = Math.min(highlight.startY, highlight.endY)
    const w = Math.abs(highlight.endX - highlight.startX)
    const h = Math.abs(highlight.endY - highlight.startY)
    return {
      id: generateUUID(),
      pageIndex: highlight.pageIndex,
      parts: [{ x, y, width: w, height: h }],
      shouldApply: true,
      isAutoGenerated: false
    }
  } else {
    // Text selection mode - render lines that intersect with the selection box
    const hl_x0 = Math.min(highlight.startX, highlight.endX)
    const hl_x1 = Math.max(highlight.startX, highlight.endX)
    const hl_y0 = Math.min(highlight.startY, highlight.endY)
    const hl_y1 = Math.max(highlight.startY, highlight.endY)

    const intersectingBoxes: any[] = page.lines.filter((line: any) => {
      const { x, y, w, h } = line.bbox
      const x1 = x + w
      const y1 = y + h
      return x <= hl_x1 && x1 >= hl_x0 && y <= hl_y1 && y1 >= hl_y0
    })

    // Adjust boxes based on start/end words
    const adjustedBoxes = intersectingBoxes.map((line: any, index: number) => {
      let { x, y, w, h } = line.bbox
      const isTopLine = index === 0
      const isBottomLine = index === intersectingBoxes.length - 1
      const isTopDown = highlight.endY > highlight.startY
      const topWord = isTopDown ? highlight.startWord : highlight.endWord
      const bottomWord = isTopDown ? highlight.endWord : highlight.startWord

      // Single-line highlight
      if (topWord && bottomWord && isTopLine && isBottomLine) {
        x = topWord.bbox.x0
        w = bottomWord.bbox.x1 - x
      }
      // Start word limits top line
      else if (topWord && isTopLine) {
        const xdiff = topWord.bbox.x0 - x
        x = topWord.bbox.x0
        w = w - xdiff
      }
      // End word limits bottom line
      else if (bottomWord && isBottomLine) {
        const xdiff = x + w - bottomWord.bbox.x1
        w = w - xdiff
      }

      return { x, y, width: w, height: h }
    })

    return {
      id: generateUUID(),
      pageIndex: highlight.pageIndex,
      parts: adjustedBoxes,
      shouldApply: true,
      isAutoGenerated: false
    }
  }
}

/**
 * Get the text content within a redaction's bounding box
 */
export function getRedactionText(redaction: Redaction, page: PageData): string {
  const bbox = boundingBox(redaction)

  // Sort all words by position (top to bottom, left to right)
  const allWords = [...page.words].sort((a, b) => {
    const yDiff = a.bbox.y0 - b.bbox.y0
    if (Math.abs(yDiff) > 5) return yDiff // Different lines
    return a.bbox.x0 - b.bbox.x0 // Same line, sort by x
  })

  // Find words that intersect with the redaction bounding box
  const redactedWords: string[] = []
  allWords.forEach(word => {
    const { x0, y0, x1, y1 } = word.bbox
    if (!(x1 < bbox.x0 || x0 > bbox.x1 || y1 < bbox.y0 || y0 > bbox.y1)) {
      redactedWords.push(word.text)
    }
  })

  return redactedWords.join(' ')
}

/**
 * Convert redactions to the format expected by MuPDF for export
 */
export function redactionsToAnnotations(redactions: Redaction[]): any[] {
  return redactions.map(redaction => ({
    content: redaction.rule?.title || '',
    position: {
      pageNumber: redaction.pageIndex,
      rect: [
        redaction.parts[0].x,
        redaction.parts[0].y,
        redaction.parts[0].x + redaction.parts[0].width,
        redaction.parts[0].y + redaction.parts[0].height
      ],
      quads: redaction.parts.map(part => [
        part.x,
        part.y,
        part.x + part.width,
        part.y,
        part.x,
        part.y + part.height,
        part.x + part.width,
        part.y + part.height
      ])
    }
  }))
}

