import { useEffect, useRef, useState } from 'react'
import type {
  PdfRedactorProps,
  Redaction,
  PageData,
  HighlightInProgress,
  WordData
} from '../types'
import { useMupdf } from '../hooks/useMupdf'
import { finalizeHighlight, redactionsToAnnotations } from '../utils/geometry'
import { PdfPage } from './PdfPage'
import { RedactionList } from './RedactionList'

export function PdfRedactor({
  file,
  redactions,
  rules = [],
  selectedId = null,
  zoom = 100,
  onRedactionAdd,
  onRedactionRemove,
  onRedactionUpdate,
  onExport,
  onSelectionChange,
  onZoomChange,
  onPageTextExtracted
}: PdfRedactorProps) {
  const {
    isWorkerInitialized,
    renderPage,
    loadDocumentAndAnnotations,
    countPages,
    getPageContent,
    getPageBounds,
    getPageWords,
    getRedactedDocument
  } = useMupdf()

  const [pages, setPages] = useState<PageData[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [currentHighlight, setCurrentHighlight] = useState<HighlightInProgress | null>(null)
  const [isDropdownOpen, setIsDropdownOpen] = useState(false)
  const [sliderValue, setSliderValue] = useState(50)

  const pdfViewerRef = useRef<HTMLDivElement>(null)
  const dropdownRef = useRef<HTMLDivElement>(null)

  // Calculate zoom from slider value (logarithmic)
  const calculateZoom = (value: number) => {
    return Math.round(50 * Math.pow(2, value / 50))
  }

  const currentZoom = zoom || calculateZoom(sliderValue)

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsDropdownOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  // Load document when file or worker changes
  useEffect(() => {
    if (!isWorkerInitialized || !file) return

    setPages([])
    setIsLoading(true)

    const init = async () => {
      const arrayBuffer = await file.arrayBuffer()
      const existingAnnotations = await loadDocumentAndAnnotations(arrayBuffer)

      // Convert existing annotations to redactions
      existingAnnotations.forEach((annotation: any) => {
        const { quads, content, pageIndex } = annotation
        const parts = quads.map((quad: any) => {
          const [x0, y0, x1, , , y2] = quad
          return { x: x0, y: y0, width: x1 - x0, height: y2 - y0 }
        })
        const rule = rules.find(r => r.title === content)
        onRedactionAdd({
          id: crypto.randomUUID(),
          pageIndex: pageIndex || 0,
          parts,
          rule,
          shouldApply: true,
          isAutoGenerated: false
        })
      })

      await loadPages()
      setIsLoading(false)
    }

    const loadPages = async () => {
      const pageStack: PageData[] = []
      const totalPages = await countPages().catch(console.error)

      if (totalPages) {
        for (let i = 0; i < totalPages; i++) {
          const pngData = await renderPage(i).catch(console.error)
          const content = JSON.parse(await getPageContent(i))
          const lines = content.blocks.flatMap((block: any) => block.lines)
          const words = await getPageWords(i)

          // Notify about extracted text for AI integration
          if (onPageTextExtracted) {
            const pageText = content.blocks
              .flatMap((block: any) => block.lines)
              .map((line: any) => line.text)
              .join(' ')
            onPageTextExtracted(pageText, i)
          }

          if (pngData) {
            pageStack.push({
              image: URL.createObjectURL(
                new Blob([new Uint8Array(pngData)], { type: 'image/png' })
              ),
              bounds: await getPageBounds(i),
              content,
              lines,
              words
            })

            if (pageStack.length === totalPages) {
              setPages(pageStack)
            }
          }
        }
      }
    }

    init()
  }, [isWorkerInitialized, file])

  // Handle export
  const handleDownload = async (applyRedactions: boolean) => {
    const applicableRedactions = redactions.filter(r => r.shouldApply !== false)
    const annotations = redactionsToAnnotations(applicableRedactions)
    const redactedPdf = await getRedactedDocument(annotations, applyRedactions)
    onExport(redactedPdf, applyRedactions)
    setIsDropdownOpen(false)
  }

  // Scroll to page
  const scrollToPage = (pageIndex: number) => {
    if (!pdfViewerRef.current) return
    const pageElements = pdfViewerRef.current.querySelectorAll('[data-page-index]')
    const targetPage = pageElements[pageIndex] as HTMLElement
    if (targetPage) {
      targetPage.scrollIntoView({ behavior: 'smooth', block: 'center' })
    }
  }

  // Drawing handlers
  const handleMouseDown = (e: React.MouseEvent<SVGSVGElement>, pageIndex: number) => {
    const target = e.target as Element
    const highlightElement = target.closest('g[data-highlight="true"]')
    if (highlightElement) return

    const page = pages[pageIndex]
    const [, , pw, ph] = page.bounds
    const svg = e.currentTarget
    const rect = svg.getBoundingClientRect()
    const scaleX = pw / rect.width
    const scaleY = ph / rect.height

    const x = (e.clientX - rect.left) * scaleX
    const y = (e.clientY - rect.top) * scaleY
    const startWord = page.words.find((word: WordData) => {
      const { x0, y0, x1, y1 } = word.bbox
      return x >= x0 && x <= x1 && y >= y0 && y <= y1
    })

    setCurrentHighlight({
      pageIndex,
      type: startWord ? 'text' : 'freehand',
      startX: x,
      startY: y,
      endX: x,
      endY: y,
      startWord: startWord || null,
      endWord: startWord || null
    })
  }

  const handleMouseMove = (e: React.MouseEvent<SVGSVGElement>) => {
    if (!currentHighlight) return

    const page = pages[currentHighlight.pageIndex]
    const [, , pw, ph] = page.bounds
    const svg = e.currentTarget
    const rect = svg.getBoundingClientRect()
    const scaleX = pw / rect.width
    const scaleY = ph / rect.height

    const currentX = (e.clientX - rect.left) * scaleX
    const currentY = (e.clientY - rect.top) * scaleY

    let newEndWord = currentHighlight.endWord
    if (currentHighlight.type === 'text') {
      newEndWord = page.words.find((word: WordData) => {
        const { x0, y0, x1, y1 } = word.bbox
        return currentX >= x0 && currentX <= x1 && currentY >= y0 && currentY <= y1
      }) || currentHighlight.endWord
    }

    setCurrentHighlight({
      ...currentHighlight,
      endX: currentX,
      endY: currentY,
      endWord: newEndWord
    })
  }

  const handleMouseUp = () => {
    if (currentHighlight) {
      const page = pages[currentHighlight.pageIndex]
      const newRedaction = finalizeHighlight(page, currentHighlight)

      // Check if area is too small
      const area = newRedaction.parts[0].width * newRedaction.parts[0].height
      if (currentHighlight.type === 'freehand' && area < 100) {
        setCurrentHighlight(null)
        return
      }

      onRedactionAdd(newRedaction)
    }
    setCurrentHighlight(null)
  }

  const handleRedactionClick = (id: string, e: React.MouseEvent) => {
    e.stopPropagation()
    e.preventDefault()
    onSelectionChange?.(id)

    // Scroll to table item
    setTimeout(() => {
      const tableItem = document.querySelector(`[data-highlight-id="${id}"]`) as HTMLElement
      if (tableItem) {
        tableItem.scrollIntoView({ behavior: 'smooth', block: 'center' })
      }
    }, 100)
  }

  const handleSliderChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(e.target.value)
    setSliderValue(value)
    onZoomChange?.(calculateZoom(value))
  }

  if (isLoading) {
    return (
      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          padding: '60px',
          textAlign: 'center',
          backgroundColor: '#f9f9f9',
          borderRadius: '8px',
          margin: '20px'
        }}
      >
        <style>
          {`@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`}
        </style>
        <div
          style={{
            border: '4px solid #f3f3f3',
            borderTop: '4px solid #4285f4',
            borderRadius: '50%',
            width: '40px',
            height: '40px',
            animation: 'spin 2s linear infinite',
            marginBottom: '16px'
          }}
        />
        <p style={{ fontWeight: 'bold' }}>PDF wird geladen...</p>
        <p style={{ color: '#666' }}>
          Bitte warten Sie, w√§hrend das Dokument verarbeitet wird.
        </p>
      </div>
    )
  }

  return (
    <div className='pdfRedactor' style={{ display: 'flex', height: '100%' }}>
      {/* Redactions Panel */}
      <div
        style={{
          width: '40%',
          borderRight: '1px solid #e0e0e0',
          overflowY: 'auto'
        }}
      >
        <RedactionList
          redactions={redactions}
          pages={pages}
          rules={rules}
          selectedId={selectedId}
          onSelectionChange={onSelectionChange || (() => {})}
          onRedactionUpdate={onRedactionUpdate}
          onScrollToPage={scrollToPage}
        />
      </div>

      {/* PDF Viewer */}
      <div
        style={{
          flex: 1,
          display: 'flex',
          flexDirection: 'column',
          position: 'relative',
          width: '60%'
        }}
      >
        {/* Controls Bar */}
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            padding: '10px 20px',
            backgroundColor: '#f8f9fa',
            borderBottom: '1px solid #e0e0e0',
            position: 'sticky',
            top: 0,
            zIndex: 100
          }}
        >
          {/* Zoom Slider */}
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              width: '240px',
              justifyContent: 'center'
            }}
          >
            <span style={{ fontWeight: 'bold', fontSize: '16px', marginRight: '8px', userSelect: 'none' }}>‚àí</span>
            <input
              type='range'
              min='0'
              max='100'
              value={sliderValue}
              onChange={handleSliderChange}
              style={{
                width: '100%',
                height: '2px',
                appearance: 'none',
                background: '#e0e0e0',
                outline: 'none',
                borderRadius: '1px',
                cursor: 'pointer'
              }}
            />
            <span style={{ fontWeight: 'bold', fontSize: '16px', marginLeft: '8px', userSelect: 'none' }}>+</span>
            <style>
              {`
                input[type="range"]::-webkit-slider-thumb {
                  appearance: none;
                  width: 12px;
                  height: 12px;
                  background: #4285f4;
                  border-radius: 50%;
                  cursor: pointer;
                  border: none;
                }
              `}
            </style>
          </div>

          {/* Save Button */}
          <div style={{ position: 'relative' }} ref={dropdownRef}>
            <button
              onClick={() => setIsDropdownOpen(!isDropdownOpen)}
              style={{
                padding: '8px 16px',
                backgroundColor: '#4285f4',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                fontWeight: 'bold',
                width: '200px'
              }}
            >
              Speichern
            </button>
            {isDropdownOpen && (
              <div
                style={{
                  position: 'absolute',
                  top: '100%',
                  right: 0,
                  backgroundColor: 'white',
                  boxShadow: '0px 4px 8px rgba(0, 0, 0, 0.1)',
                  borderRadius: '4px',
                  zIndex: 10,
                  width: '200px'
                }}
              >
                <div
                  style={{ padding: '8px 16px', cursor: 'pointer', display: 'flex', alignItems: 'center' }}
                  onClick={() => handleDownload(false)}
                  onMouseEnter={e => (e.currentTarget.style.backgroundColor = '#f5f5f5')}
                  onMouseLeave={e => (e.currentTarget.style.backgroundColor = 'transparent')}
                >
                  <span style={{ marginRight: '8px' }}>üü®</span> Vorgeschw√§rzt
                </div>
                <div
                  style={{ padding: '8px 16px', cursor: 'pointer', display: 'flex', alignItems: 'center' }}
                  onClick={() => handleDownload(true)}
                  onMouseEnter={e => (e.currentTarget.style.backgroundColor = '#f5f5f5')}
                  onMouseLeave={e => (e.currentTarget.style.backgroundColor = 'transparent')}
                >
                  <span style={{ marginRight: '8px' }}>‚¨õÔ∏è</span> Final geschw√§rzt
                </div>
              </div>
            )}
          </div>
        </div>

        {/* PDF Content */}
        <div
          ref={pdfViewerRef}
          style={{
            flex: 1,
            maxWidth: '100%',
            overflowX: 'scroll',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            position: 'relative',
            maxHeight: '100%',
            overflowY: 'scroll'
          }}
        >
          {pages.map((page, i) => (
            <PdfPage
              key={`page-${i}`}
              pageIndex={i}
              pageData={page}
              zoom={currentZoom}
              redactions={redactions}
              selectedId={selectedId}
              currentHighlight={currentHighlight}
              onRedactionClick={handleRedactionClick}
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
            />
          ))}
        </div>
      </div>
    </div>
  )
}

